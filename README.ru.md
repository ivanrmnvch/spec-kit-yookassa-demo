# YooKassa Payment Flow Demo

***[English](README.md)** | Русский*

Демонстрационный проект портфолио, демонстрирующий интеграцию платежей с провайдером YooKassa для SaaS-приложения. Этот проект демонстрирует понимание проблем обработки платежей и их решений.

## Обзор

Этот проект демонстрирует:
- Чистую, современную backend-разработку с использованием принципов Spec-Driven Development
- Полную интеграцию платежного потока с YooKassa (создание платежа, отслеживание статуса, обработка webhook)
- Выявление и решение критических проблем обработки платежей
- Соблюдение конституционных принципов, определенных в `.specify/memory/constitution.md`

## Технологический стек

- **Среда выполнения**: Node.js 20+ с TypeScript (строгий режим)
- **Фреймворк**: Express.js
- **ORM**: Prisma с PostgreSQL
- **Кэш**: Redis (ключи идемпотентности + rate limiting)
- **HTTP клиент**: Axios с логикой повторных попыток
- **Валидация**: Zod (типобезопасная валидация схем)
- **Логирование**: Pino (структурированные JSON логи)
- **Документация**: OpenAPI/Swagger
- **Тестирование**: Jest + ts-jest
- **Контейнеризация**: Docker + Docker Compose

## Структура проекта

```
src/
├── app.ts                    # Точка входа приложения
├── config/                   # Конфигурация (env, database, redis, yookassa)
├── controllers/              # Обработчики запросов (payments, webhooks)
├── middlewares/              # Express middleware (валидация, rate limiting и т.д.)
├── repositories/            # Слой доступа к данным (User, Payment)
├── routes/                   # Определения маршрутов
├── services/                 # Бизнес-логика (Payment, Webhook, YooKassa, Idempotency)
├── types/                    # Определения типов TypeScript
└── utils/                    # Утилиты (logger, request hash)

prisma/
├── schema.prisma             # Схема базы данных
└── migrations/               # Миграции базы данных

specs/001-yookassa-payment-flow/
├── spec.md                   # Спецификация функциональности
├── plan.md                   # План реализации
├── research.md               # Технические исследования и решения
├── data-model.md             # Дизайн базы данных
├── tasks.md                  # Разбивка задач
├── quickstart.md             # Руководство по быстрому старту
└── contracts/                # Контракты API (OpenAPI)
```

## Требования

- Node.js 20+
- Docker & Docker Compose
- npm или yarn
- Тестовые учетные данные YooKassa (shop ID + secret key)
- ngrok (для тестирования webhook в разработке)

## Быстрый старт

### 1. Настройка окружения

Создайте файл `.env` в корне проекта:

```env
# База данных
DATABASE_URL="postgresql://postgres:postgres@localhost:5432/payment_service"

# Redis
REDIS_URL="redis://localhost:6379"

# YooKassa
YOOKASSA_SHOP_ID="your-shop-id"
YOOKASSA_SECRET_KEY="your-secret-key"
YOOKASSA_BASE_URL="https://api.yookassa.ru/v3"

# Приложение
PORT=3000
NODE_ENV=development

# Доверенный прокси (установите true, если за reverse proxy)
TRUSTED_PROXY=false
```

### 2. Установка зависимостей

```bash
npm install
```

### 3. Запуск зависимостей

```bash
docker compose up -d
```

Это запускает контейнеры PostgreSQL и Redis.

### 4. Запуск миграций и заполнение данных

```bash
npx prisma migrate dev
npx prisma db seed
```

Скрипт seed создает 3 тестовых пользователя для разработки.

### 5. Запуск сервера разработки

```bash
npm run dev
```

API будет доступен по адресу `http://localhost:3000`

### 6. Экспорт webhook через ngrok

Для тестирования webhook, откройте локальный сервер:

```bash
ngrok http 3000
```

Настройте URL webhook YooKassa в панели управления YooKassa:
- `https://<ngrok-subdomain>.ngrok.io/api/webhooks/yookassa`

## API Endpoints

### Платежи

- `POST /api/payments` - Создать платеж (идемпотентный, требует заголовок `Idempotence-Key`)
- `GET /api/payments/:id` - Получить статус платежа по внутреннему ID

### Webhook

- `POST /api/webhooks/yookassa` - Получить уведомления webhook от YooKassa (применяется IP allowlist)

### Health

- `GET /health` - Endpoint проверки работоспособности

## Примеры запросов

### Создать платеж

```bash
curl -X POST http://localhost:3000/api/payments \
  -H "Content-Type: application/json" \
  -H "Idempotence-Key: 11111111-1111-4111-8111-111111111111" \
  -H "X-Correlation-Id: demo-req-001" \
  -d '{
    "userId": "00000000-0000-4000-8000-000000000001",
    "amount": { "value": "100.00", "currency": "RUB" },
    "returnUrl": "https://example.com/payment/result",
    "description": "Premium subscription",
    "metadata": { 
      "plan_type": "premium", 
      "billing_period": "monthly",
      "userId": "00000000-0000-4000-8000-000000000001"
    }
  }'
```

**Ответ (201 Created для нового платежа, 200 OK для идемпотентного повтора):**
```json
{
  "id": "550e8400-e29b-41d4-a716-446655440000",
  "yookassa_payment_id": "22e12a6f-000f-5000-9000-1a2b3c4d5e6f",
  "status": "pending",
  "amount": "100.00",
  "currency": "RUB",
  "paid": false,
  "confirmation_url": "https://yoomoney.ru/checkout/payments/v2/contract?orderId=...",
  "metadata": { "plan_type": "premium", "billing_period": "monthly", "userId": "..." },
  "created_at": "2026-01-29T12:00:00.000Z",
  "updated_at": "2026-01-29T12:00:00.000Z"
}
```

### Получить статус платежа

```bash
curl http://localhost:3000/api/payments/550e8400-e29b-41d4-a716-446655440000
```

**Ответ (200 OK):**
```json
{
  "id": "550e8400-e29b-41d4-a716-446655440000",
  "yookassa_payment_id": "22e12a6f-000f-5000-9000-1a2b3c4d5e6f",
  "status": "succeeded",
  "amount": "100.00",
  "currency": "RUB",
  "paid": true,
  "confirmation_url": null,
  "metadata": { "plan_type": "premium", "billing_period": "monthly", "userId": "..." },
  "cancellation_details": null,
  "created_at": "2026-01-29T12:00:00.000Z",
  "updated_at": "2026-01-29T12:05:00.000Z",
  "captured_at": "2026-01-29T12:05:00.000Z",
  "canceled_at": null
}
```

### Идемпотентный повтор (тот же ключ, то же тело)

Повторите тот же запрос с тем же `Idempotence-Key` и тем же телом:
- Ожидается `200 OK` (попадание в кэш идемпотентности)
- Тот же `id` и тот же `yookassa_payment_id`

## Разработка

### Запуск тестов

```bash
# Unit тесты
npm test

# Режим наблюдения
npm run test:watch
```

**Покрытие тестами**: 82 проходящих теста, покрывающих:
- Переходы state machine платежей
- Сервис идемпотентности (кэширование Redis, конфликты хэшей)
- Обработка webhook (IP allowlist, валидация payload, верификация, восстановление)
- Обработка ошибок (timeout/5xx повторяемые ошибки)
- Интеграция сервиса YooKassa
- Создание и получение платежей

### Команды Prisma

```bash
# Генерация Prisma Client
npx prisma generate

# Создание миграции
npx prisma migrate dev

# Открыть Prisma Studio (GUI БД)
npx prisma studio
```

### Линтинг и форматирование

```bash
# Линтинг
npm run lint

# Форматирование
npm run format:write
```

## Docker Deployment

Сборка и запуск с Docker Compose:

```bash
docker compose up --build
```

API будет доступен по адресу `http://localhost:3000`

## Архитектура и паттерны проектирования

### Многослойная архитектура
- **Controllers**: Обработка HTTP запросов/ответов
- **Services**: Оркестрация бизнес-логики
- **Repositories**: Абстракция доступа к данным
- **Middlewares**: Сквозные задачи (валидация, rate limiting, логирование)

### Паттерны безопасности
- **IP Allowlisting**: Webhook endpoints принимают запросы только с IP-адресов YooKassa
- **Верификация Webhook**: Всегда проверяйте данные webhook через YooKassa GET API (источник истины)
- **Валидация входных данных**: Схемы Zod для всех DTO запросов
- **Rate Limiting**: API endpoints защищены (100 запросов/15мин), create-payment строже (10 запросов/час)

### Обработка ошибок
- **Глобальный обработчик ошибок**: Единый JSON envelope ошибок для всех endpoints
- **Повторяемые ошибки**: Ответы 503 с `retryable=true` и `sameIdempotenceKey=true` для временных сбоев
- **HTTP коды статуса**:
  - 200/201: Успех
  - 400: Неверный запрос (ошибки валидации)
  - 403: Запрещено (неразрешенный IP для webhook)
  - 404: Не найдено (пользователь/платеж не найден)
  - 409: Конфликт (несоответствие хэша ключа идемпотентности)
  - 429: Слишком много запросов (превышен лимит)
  - 503: Сервис недоступен (повторяемые ошибки upstream)

### Логирование и наблюдаемость
- **Структурированное логирование**: JSON логи Pino с `correlationId` для сквозной трассировки
- **Логирование запросов**: Все входящие запросы логируются с correlation ID
- **Исходящие вызовы**: Все вызовы API YooKassa логируются (запрос/ответ)
- **Логирование Webhook**: Полные payload webhook логируются для отладки

## Критические проблемы, выявленные и решенные

На основе требований выявить проблемы обработки платежей, были выявлены и решены следующие проблемы:

### 1. **Идемпотентность и предотвращение дубликатов**

**Проблема**: 
- Повторные попытки клиента или двойные клики могут создавать дубликаты платежей
- Неизвестный исход сбоев (timeout/5xx) делает неясным, был ли создан платеж
- Тот же ключ идемпотентности с разным телом запроса создает конфликты

**Решение**:
- **Идемпотентность на основе Redis**: Хранение записей идемпотентности в Redis с TTL 24 часа (соответствует окну YooKassa)
- **Валидация хэша запроса**: Вычисление SHA-256 хэша тела запроса; возврат `409 Conflict`, если тот же ключ используется с другим телом
- **Идемпотентный повтор**: Возврат кэшированного ответа (200 OK) для того же ключа + тот же хэш
- **Руководство по повтору**: Возврат `503` с `sameIdempotenceKey=true` для ошибок с неизвестным исходом

**Реализация**:
- `IdempotencyService` управляет ключами Redis с детерминированным хэшированием
- `PaymentService` проверяет идемпотентность перед созданием платежа
- Обработчик ошибок преобразует timeout/5xx в повторяемый envelope 503

### 2. **Безопасность Webhook и доверие**

**Проблема**:
- Webhook могут быть подделаны (фейковые уведомления)
- Payload webhook может содержать неверные или устаревшие данные
- Неупорядоченная доставка webhook может вызвать коррупцию состояния

**Решение**:
- **IP Allowlisting**: Отклонение webhook с не-YooKassa IP (403 Forbidden)
- **GET верификация**: Всегда проверяйте данные webhook через `GET /v3/payments/{id}` перед любой мутацией БД
- **Источник истины**: API YooKassa является авторитетным; payload webhook только для ввода
- **Идемпотентные обновления**: State machine предотвращает недопустимые переходы и обрабатывает дубликаты корректно

**Реализация**:
- `webhookIpAllowlistMiddleware` применяет IP allowlist
- `WebhookService.processWebhook` выполняет GET верификацию перед обработкой
- `PaymentStateMachine` обеспечивает только допустимые переходы и идемпотентные обновления

### 3. **Неизвестный исход сбоев (Timeout/5xx)**

**Проблема**:
- Таймауты сети или ошибки 5xx YooKassa оставляют исход создания платежа неизвестным
- Клиент не знает, был ли создан платеж или нет
- Повтор с новым ключом идемпотентности может создавать дубликаты

**Решение**:
- **Envelope повторяемых ошибок**: Возврат `503 Service Unavailable` с `retryable=true` и `sameIdempotenceKey=true`
- **Логика повторных попыток Axios**: Автоматические повторы для GET и идемпотентных POST запросов (с `Idempotence-Key`)
- **Ограниченные повторы**: Максимум 3 повтора с экспоненциальной задержкой
- **Четкое руководство**: Ответ ошибки явно инструктирует клиента повторить с тем же ключом

**Реализация**:
- `RetryableUpstreamError` тип доменной ошибки
- `error-handler.ts` преобразует Axios timeout/5xx в envelope 503
- `yookassa.ts` настраивает interceptor Axios для логики повторных попыток

### 4. **Неупорядоченная доставка Webhook**

**Проблема**:
- Webhook могут прибывать не по порядку (например, `payment.succeeded` до `payment.pending`)
- Дубликаты webhook могут вызвать коррупцию состояния
- Гонки между webhook и polling

**Решение**:
- **State Machine**: Обеспечивает только допустимые переходы (`pending → succeeded|canceled`)
- **Идемпотентные обновления**: Обновление того же статуса является no-op
- **Неизменяемость финального состояния**: После `succeeded` или `canceled` статус не может измениться
- **GET верификация**: Всегда используйте текущий статус из API YooKassa, а не payload webhook

**Реализация**:
- `PaymentStateMachine` валидирует переходы
- `PaymentService.updatePaymentStatus` проверяет state machine перед обновлением
- Обработка webhook использует проверенный статус из GET запроса

### 5. **Гонка Webhook-перед-POST**

**Проблема**:
- YooKassa может отправить уведомление webhook до возврата ответа `POST /payments`
- Локальная запись платежа может еще не существовать
- Обработка webhook терпит неудачу или создает сиротские записи

**Решение**:
- **Восстановление платежа**: Если webhook приходит для несуществующего платежа, восстановите его из API YooKassa
- **Требование метаданных**: `metadata.userId` требуется для восстановления
- **Идемпотентное создание**: Обработка гонки, где платеж создается конкурентно

**Реализация**:
- `WebhookService.restorePayment` создает локальную запись из данных YooKassa
- Корректно обрабатывает гонку конкурентного создания
- Валидирует `userId` в метаданных перед восстановлением

### 6. **Rate Limiting и предотвращение злоупотреблений**

**Проблема**:
- Публичные API endpoints уязвимы для злоупотреблений
- Endpoint создания платежа нуждается в более строгих лимитах
- Webhook не должны быть ограничены rate limiting (YooKassa повторяет)

**Решение**:
- **Многоуровневый Rate Limiting**: 
  - Общий API: 100 запросов / 15 минут / IP
  - Создание платежа: 10 запросов / 60 минут / (IP + userId)
  - Webhook: Без rate limiting
- **На основе Redis**: Лимиты скорости хранятся в Redis для распределенных систем
- **Стандартные заголовки**: Возврат заголовков `RateLimit-*` для осведомленности клиента

**Реализация**:
- `rate-limiter.ts` создает Express rate limiters с Redis store
- Разные лимиты для разных endpoints
- Маршруты webhook явно исключены из rate limiting

### 7. **Трассировка запросов и отладка**

**Проблема**:
- Сложно отследить поток платежа через несколько сервисов
- Нет способа коррелировать логи от API запроса → YooKassa → webhook

**Решение**:
- **Correlation ID**: Генерация или принятие заголовка `X-Correlation-Id`
- **Структурированное логирование**: Все логи включают `correlationId` для фильтрации
- **Сквозная трассировка**: Correlation ID передается в сервис YooKassa и обработку webhook

**Реализация**:
- `correlationIdMiddleware` генерирует/принимает correlation ID
- Все сервисы логируют с контекстом `correlationId`
- Структурированные JSON логи Pino позволяют легко фильтровать

### 8. **Защита схемы базы данных**

**Проблема**:
- Дубликат `yookassa_payment_id` может вызвать коррупцию данных
- Конкурентная обработка webhook может создавать дубликаты

**Решение**:
- **Уникальное ограничение**: `yookassa_payment_id` имеет уникальное ограничение в базе данных
- **Обработка ошибок**: Корректная обработка нарушений уникального ограничения
- **Идемпотентные операции**: Все операции безопасны для повтора

**Реализация**:
- Схема Prisma применяет уникальное ограничение
- `PaymentRepository` обрабатывает нарушения уникального ограничения
- Обработка webhook проверяет существующий платеж перед созданием

## Тестирование

### Unit тесты

Вся критическая логика имеет комплексное покрытие unit тестами:
- **PaymentStateMachine**: 18 тестов (переходы, неизменяемость, идемпотентность)
- **IdempotencyService**: 6 тестов (get, set, обнаружение конфликтов)
- **Обработка Webhook**: 15 тестов (IP allowlist, валидация payload, верификация, восстановление, обновления статуса)
- **Обработка ошибок**: 7 тестов (timeout/5xx повторяемые ошибки)
- **Сервис YooKassa**: 3 теста (создание платежа, логика повторных попыток)

**Всего: 82 проходящих теста**

```bash
npm test
```

### Покрытие тестами

- Покрытие бизнес-логики: >80%
- Критические пути: идемпотентность, state machine, безопасность webhook, обработка ошибок
- Граничные случаи: дубликаты, неупорядоченность, гонки, неизвестный исход сбоев

## Решение проблем

### Типичные проблемы

**Ошибка подключения к базе данных**
```bash
# Убедитесь, что PostgreSQL запущен
docker compose ps
docker compose up postgres -d
```

**Ошибка подключения к Redis**
```bash
# Убедитесь, что Redis запущен
docker compose ps
docker compose up redis -d
```

**Проблемы с миграциями**
```bash
# Сбросить базу данных и перезапустить миграции
docker compose down -v
docker compose up -d
npx prisma migrate dev
npx prisma db seed
```

**Webhook не получен**
```bash
# Проверьте, что ngrok запущен и URL настроен в панели YooKassa
ngrok http 3000

# Проверьте IP allowlist webhook (должен быть с IP YooKassa)
# Проверьте логи на ошибки 403 Forbidden
```

**Конфликт ключа идемпотентности**
```bash
# Используйте другой ключ идемпотентности для разных тел запросов
# Или подождите 24 часа для истечения TTL
```

**Порт уже используется**
```bash
# Измените PORT в файле .env
PORT=3001
```

## Переменные окружения

Обязательные переменные в `.env`:

```env
# База данных
DATABASE_URL="postgresql://postgres:postgres@localhost:5432/payment_service"

# Redis
REDIS_URL="redis://localhost:6379"

# YooKassa
YOOKASSA_SHOP_ID="your-shop-id"
YOOKASSA_SECRET_KEY="your-secret-key"
YOOKASSA_BASE_URL="https://api.yookassa.ru/v3"

# Приложение
PORT=3000
NODE_ENV=development

# Доверенный прокси (для извлечения IP webhook за reverse proxy)
TRUSTED_PROXY=false
```

## Соображения производительности

- **Индексы базы данных**: Индексирование по `yookassa_payment_id` (уникальный), `user_id` для запросов
- **Кэширование Redis**: Ключи идемпотентности кэшируются с TTL 24 часа
- **Пул соединений**: Prisma использует пул соединений PostgreSQL
- **Логика повторных попыток**: Ограниченные повторы (макс. 3) с экспоненциальной задержкой для upstream вызовов
- **Rate Limiting**: Предотвращает злоупотребления, позволяя легитимный трафик

## Конституция и Spec-Driven Development

Этот проект следует рабочему процессу Spec-Driven Development:

1. **Конституция** (`.specify/memory/constitution.md`) - Определяет принципы и стандарты
2. **Спецификация** (`specs/001-yookassa-payment-flow/spec.md`) - Пользовательские истории и требования
3. **Исследование** (`specs/001-yookassa-payment-flow/research.md`) - Технические решения и альтернативы
4. **План** (`specs/001-yookassa-payment-flow/plan.md`) - Технический план реализации
5. **Задачи** (`specs/001-yookassa-payment-flow/tasks.md`) - Разбивка на выполнимые задачи
6. **Реализация** - Этот код

Все артефакты остаются согласованными с принципами конституции.

## Ключевые функции

### Поток платежей
- ✅ Создание одноэтапного платежа с URL перенаправления
- ✅ Отслеживание статуса платежа (pending → succeeded|canceled)
- ✅ Идемпотентное создание платежа (Redis + хэш запроса)
- ✅ Восстановление платежа из webhook (сценарий webhook-перед-POST)

### Обработка Webhook
- ✅ Применение IP allowlist (только IP YooKassa)
- ✅ Верификация webhook через YooKassa GET API (источник истины)
- ✅ Идемпотентные обновления статуса (обрабатывает дубликаты/неупорядоченность)
- ✅ Восстановление платежа для отсутствующих записей

### Обработка ошибок
- ✅ Envelope повторяемых ошибок (503 с `retryable=true`, `sameIdempotenceKey=true`)
- ✅ Логика повторных попыток Axios для GET и идемпотентных POST
- ✅ Graceful shutdown (HTTP сервер + Prisma + Redis)
- ✅ Комплексное логирование ошибок с correlation ID

### Безопасность и надежность
- ✅ Валидация входных данных с Zod (типобезопасные схемы)
- ✅ Rate limiting (API + endpoints создания платежа)
- ✅ IP allowlisting webhook
- ✅ State machine предотвращает недопустимые переходы
- ✅ Уникальное ограничение на `yookassa_payment_id`

### Наблюдаемость
- ✅ Структурированное JSON логирование (Pino)
- ✅ Correlation ID для сквозной трассировки
- ✅ Логирование запросов/ответов
- ✅ Логирование payload webhook

### Качество кода
- ✅ TypeScript строгий режим (без типов `any`)
- ✅ Модульная архитектура (controllers, services, repositories)
- ✅ Глобальная обработка ошибок
- ✅ Unit тесты (82 проходящих теста)
- ✅ OpenAPI документация

## Лицензия

MIT

## Автор

Портфолио/демо проект для демонстрации навыков интеграции платежей и понимания проблем обработки платежей.

